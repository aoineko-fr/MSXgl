<!DOCTYPE html>

<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>qrcode.h</title><link rel="stylesheet" type="text/css" href="../../styles/main.css" /><script type="text/javascript" src="../../styles/main.js"></script><script type="text/javascript">NDLoader.LoadJS("Content", "../../styles/");</script></head>

<!-- Generated by Natural Docs, version 2.2 -->

<!-- saved from url=(0016)http://localhost -->

<body onload="NDLoader.OnLoad('Content');" class="NDPage NDContentPage">

<a name="Types"></a><a name="Topic786"></a><div class="CTopic TGroup LC first">
 <div class="CTitle">Types</div>
</div>

<a name="QRCODE_ECC"></a><a name="Topic894"></a><div class="CTopic TEnumeration LC">
 <div class="CTitle">QRCODE_ECC</div>
 <div class="CBody"><p>The error correction level in a QR Code symbol.&nbsp; enum QRCODE_ECC { // Must be declared in ascending order of error protection // so that an internal qrcodegen function works properly QRCODE_ECC_LOW = 0 ,&nbsp; // The QR Code can tolerate about&nbsp; 7% erroneous codewords QRCODE_ECC_MEDIUM&nbsp; ,&nbsp; // The QR Code can tolerate about 15% erroneous codewords QRCODE_ECC_QUARTILE,&nbsp; // The QR Code can tolerate about 25% erroneous codewords QRCODE_ECC_HIGH&nbsp; ,&nbsp; // The QR Code can tolerate about 30% erroneous codewords // QRCODE_ECC_MAX, };</p></div>
</div>

<a name="QRCODE_MASK"></a><a name="Topic935"></a><div class="CTopic TEnumeration LC">
 <div class="CTitle">QRCODE_MASK</div>
 <div class="CBody"><p>The mask pattern used in a QR Code symbol.&nbsp; enum QRCODE_MASK { // A special value to tell the QR Code encoder to // automatically select an appropriate mask pattern QRCODE_MASK_AUTO = -1, // The eight actual mask patterns QRCODE_MASK_0 = 0, // (i + j) % 2 = 0 QRCODE_MASK_1,&nbsp; // i % 2 = 0 QRCODE_MASK_2,&nbsp; // j % 3 = 0 QRCODE_MASK_3,&nbsp; // (i + j) % 3 = 0 QRCODE_MASK_4,&nbsp; // (i / 2 + j / 3) % 2 = 0 QRCODE_MASK_5,&nbsp; // (i * j) % 2 + (i * j) % 3 = 0 QRCODE_MASK_6,&nbsp; // ((i * j) % 3 + i * j) % 2 = 0 QRCODE_MASK_7,&nbsp; // ((i * j) % 3 + i + j) % 2 = 0 // QRCODE_MASK_MAX, };</p></div>
</div>

<a name="QRCODE_MODE"></a><a name="Topic834"></a><div class="CTopic TEnumeration LC">
 <div class="CTitle">QRCODE_MODE</div>
 <div class="CBody"><p>Describes how a segment's data bits are interpreted.</p></div>
</div>

<a name="Macros"></a><a name="Topic1109"></a><div class="CTopic TGroup LC">
 <div class="CTitle">Macros</div>
</div>

<a name="QRCODE_BUFFER_LEN_FOR_VERSION"></a><a name="Topic1110"></a><div class="CTopic TMacro LC">
 <div class="CTitle">QRCODE_BUFFER_LEN_FOR_VERSION</div>
 <div class="CBody"><p>Calculates the number of bytes needed to store any QR Code up to and including the given version number, as a compile-time constant. For example, 'u8 buffer[QRCODE_BUFFER_LEN_FOR_VERSION(25)];' can store any single QR Code from version 1 to 25 (inclusive). The result fits in an i16 (or int16).&nbsp; Requires QRCODE_VERSION_MIN &lt;= n &lt;= QRCODE_VERSION_MAX.</p></div>
</div>

<a name="QRCODE_BUFFER_LEN_MAX"></a><a name="Topic1111"></a><div class="CTopic TMacro LC">
 <div class="CTitle">QRCODE_BUFFER_LEN_MAX</div>
 <div class="CBody"><p>The worst-case number of bytes needed to store one QR Code, up to and including version 40. This value equals 3918, which is just under 4 kilobytes.&nbsp; Use this more convenient value to avoid calculating tighter memory bounds for buffers.</p></div>
</div>

<a name="Functions"></a><a name="Topic1112"></a><div class="CTopic TGroup LC">
 <div class="CTitle">Functions</div>
</div>

<a name="QRCode_EncodeText"></a><a name="Topic977"></a><div class="CTopic TFunction LC">
 <div class="CTitle">QRCode_EncodeText</div>
 <div id="NDPrototype977" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">bool</span> QRCode_EncodeText(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">const</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PSymbols">*</td><td class="PName last">text,</td></tr><tr><td class="first"></td><td class="PType">u8&nbsp;</td><td></td><td class="PName last">tempBuffer[],</td></tr><tr><td class="first"></td><td class="PType">u8&nbsp;</td><td></td><td class="PName last">qrcode[],</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">enum</span>&nbsp;</td><td class="PType"><a href="../../index.html#File:tool/qrcode.h:QRCODE_ECC" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,894);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >QRCODE_ECC</a>&nbsp;</td><td></td><td class="PName last">ecl,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">enum</span>&nbsp;</td><td class="PType"><a href="../../index.html#File:tool/qrcode.h:QRCODE_MASK" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,935);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >QRCODE_MASK</a>&nbsp;</td><td></td><td class="PName last">mask</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div></div>
 <div class="CBody"><p>Encodes the given text string to a QR Code, returning TRUE if successful.&nbsp; If the data is too long to fit in any version in the given range at the given ECC level, then FALSE is returned.</p><p>The input text must be encoded in UTF-8 and contain no NULs.&nbsp; Requires 1 &lt;= minVersion &lt;= maxVersion &lt;= 40.</p><p>The smallest possible QR Code version within the given range is automatically chosen for the output. Iff boostEcl is TRUE, then the ECC level of the result may be higher than the ecl argument if it can be done without increasing the version. The mask is either between QRCODE_MASK_0 to 7 to force that mask, or QRCODE_MASK_AUTO to automatically choose an appropriate mask (which may be slow).</p><p>About the arrays, letting len = QRCODE_BUFFER_LEN_FOR_VERSION(maxVersion): - Before calling the function: - The array ranges tempBuffer[0 : len] and qrcode[0 : len] must allow reading and writing; hence each array must have a length of at least len.&nbsp; - The two ranges must not overlap (aliasing).&nbsp; - The initial state of both ranges can be uninitialized because the function always writes before reading.&nbsp; - After the function returns: - Both ranges have no guarantee on which elements are initialized and what values are stored.&nbsp; - tempBuffer contains no useful data and should be treated as entirely uninitialized.&nbsp; - If successful, qrcode can be passed into QRCode_GetSize() and QRCode_GetModule().</p><p>If successful, the resulting QR Code may use numeric, alphanumeric, or byte mode to encode the text.</p><p>In the most optimistic case, a QR Code at version 40 with low ECC can hold any UTF-8 string up to 2953 bytes, or any alphanumeric string up to 4296 characters, or any digit string up to 7089 characters.&nbsp; These numbers represent the hard upper limit of the QR Code standard.</p><p>Please consult the QR Code specification for information on data capacities per version, ECC level, and text encoding mode.</p></div>
</div>

<a name="QRCode_EncodeBinary"></a><a name="Topic978"></a><div class="CTopic TFunction LC">
 <div class="CTitle">QRCode_EncodeBinary</div>
 <div id="NDPrototype978" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">bool</span> QRCode_EncodeBinary(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="first"></td><td class="PType">u8&nbsp;</td><td class="PName last">dataAndTemp[],</td></tr><tr><td class="first"></td><td class="PType">u16&nbsp;</td><td class="PName last">dataLen,</td></tr><tr><td class="first"></td><td class="PType">u8&nbsp;</td><td class="PName last">qrcode[],</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">enum</span>&nbsp;</td><td class="PType"><a href="../../index.html#File:tool/qrcode.h:QRCODE_ECC" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,894);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >QRCODE_ECC</a>&nbsp;</td><td class="PName last">ecl,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">enum</span>&nbsp;</td><td class="PType"><a href="../../index.html#File:tool/qrcode.h:QRCODE_MASK" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,935);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >QRCODE_MASK</a>&nbsp;</td><td class="PName last">mask</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div></div>
 <div class="CBody"><p>Encodes the given binary data to a QR Code, returning TRUE if successful.&nbsp; If the data is too long to fit in any version in the given range at the given ECC level, then FALSE is returned.</p><p>Requires 1 &lt;= minVersion &lt;= maxVersion &lt;= 40.</p><p>The smallest possible QR Code version within the given range is automatically chosen for the output. If boostEcl is TRUE, then the ECC level of the result may be higher than the ecl argument if it can be done without increasing the version. The mask is either between QRCODE_MASK_0 to 7 to force that mask, or QRCODE_MASK_AUTO to automatically choose an appropriate mask (which may be slow).</p><p>About the arrays, letting len = QRCODE_BUFFER_LEN_FOR_VERSION(maxVersion): - Before calling the function: - The array ranges dataAndTemp[0 : len] and qrcode[0 : len] must allow reading and writing; hence each array must have a length of at least len.&nbsp; - The two ranges must not overlap (aliasing).&nbsp; - The input array range dataAndTemp[0 : dataLen] should normally be valid UTF-8 text, but is not required by the QR Code standard.&nbsp; - The initial state of dataAndTemp[dataLen : len] and qrcode[0 : len] can be uninitialized because the function always writes before reading.&nbsp; - After the function returns: - Both ranges have no guarantee on which elements are initialized and what values are stored.&nbsp; - dataAndTemp contains no useful data and should be treated as entirely uninitialized.&nbsp; - If successful, qrcode can be passed into QRCode_GetSize() and QRCode_GetModule().</p><p>If successful, the resulting QR Code will use byte mode to encode the data.</p><p>In the most optimistic case, a QR Code at version 40 with low ECC can hold any byte sequence up to length 2953. This is the hard upper limit of the QR Code standard.</p><p>Please consult the QR Code specification for information on data capacities per version, ECC level, and text encoding mode.</p></div>
</div>

<a name="QRCode_EncodeSegments"></a><a name="Topic42"></a><div class="CTopic TFunction LC">
 <div class="CTitle">QRCode_EncodeSegments</div>
 <div id="NDPrototype42" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">bool</span> QRCode_EncodeSegments(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">const</span>&nbsp;</td><td class="PType">QRCode_Segment&nbsp;</td><td class="PName last">segs[],</td></tr><tr><td class="first"></td><td class="PType">u16&nbsp;</td><td class="PName last">len,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">enum</span>&nbsp;</td><td class="PType"><a href="../../index.html#File:tool/qrcode.h:QRCODE_ECC" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,894);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >QRCODE_ECC</a>&nbsp;</td><td class="PName last">ecl,</td></tr><tr><td class="first"></td><td class="PType">u8&nbsp;</td><td class="PName last">tempBuffer[],</td></tr><tr><td class="first"></td><td class="PType">u8&nbsp;</td><td class="PName last">qrcode[]</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div></div>
 <div class="CBody"><p>Encodes the given segments to a QR Code, returning TRUE if successful.&nbsp; If the data is too long to fit in any version at the given ECC level, then FALSE is returned.</p><p>The smallest possible QR Code version is automatically chosen for the output. The ECC level of the result may be higher than the ecl argument if it can be done without increasing the version.</p><p>About the byte arrays, letting len = QRCODE_BUFFER_LEN_FOR_VERSION(QRCODE_VERSION_MAX): - Before calling the function: - The array ranges tempBuffer[0 : len] and qrcode[0 : len] must allow reading and writing; hence each array must have a length of at least len.&nbsp; - The two ranges must not overlap (aliasing).&nbsp; - The initial state of both ranges can be uninitialized because the function always writes before reading.&nbsp; - The input array segs can contain segments whose data buffers overlap with tempBuffer.&nbsp; - After the function returns: - Both ranges have no guarantee on which elements are initialized and what values are stored.&nbsp; - tempBuffer contains no useful data and should be treated as entirely uninitialized.&nbsp; - Any segment whose data buffer overlaps with tempBuffer[0 : len] must be treated as having invalid values in that array.&nbsp; - If successful, qrcode can be passed into QRCode_GetSize() and QRCode_GetModule().</p><p>Please consult the QR Code specification for information on data capacities per version, ECC level, and text encoding mode.</p><p>This function allows the user to create a custom sequence of segments that switches between modes (such as alphanumeric and byte) to encode text in less space.&nbsp; This is a low-level API; the high-level API is QRCode_EncodeText() and QRCode_EncodeBinary().</p></div>
</div>

<a name="QRCode_EncodeSegmentsAdvanced"></a><a name="Topic587"></a><div class="CTopic TFunction LC">
 <div class="CTitle">QRCode_EncodeSegmentsAdvanced</div>
 <div id="NDPrototype587" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">bool</span> QRCode_EncodeSegmentsAdvanced(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">const</span>&nbsp;</td><td class="PType">QRCode_Segment&nbsp;</td><td class="PName last">segs[],</td></tr><tr><td class="first"></td><td class="PType">u16&nbsp;</td><td class="PName last">len,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">enum</span>&nbsp;</td><td class="PType"><a href="../../index.html#File:tool/qrcode.h:QRCODE_ECC" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,894);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >QRCODE_ECC</a>&nbsp;</td><td class="PName last">ecl,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">enum</span>&nbsp;</td><td class="PType"><a href="../../index.html#File:tool/qrcode.h:QRCODE_MASK" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,935);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >QRCODE_MASK</a>&nbsp;</td><td class="PName last">mask,</td></tr><tr><td class="first"></td><td class="PType">u8&nbsp;</td><td class="PName last">tempBuffer[],</td></tr><tr><td class="first"></td><td class="PType">u8&nbsp;</td><td class="PName last">qrcode[]</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div></div>
 <div class="CBody"><p>Encodes the given segments to a QR Code, returning TRUE if successful.&nbsp; If the data is too long to fit in any version in the given range at the given ECC level, then FALSE is returned.</p><p>Requires 1 &lt;= minVersion &lt;= maxVersion &lt;= 40.</p><p>The smallest possible QR Code version within the given range is automatically chosen for the output. Iff boostEcl is TRUE, then the ECC level of the result may be higher than the ecl argument if it can be done without increasing the version. The mask is either between QRCODE_MASK_0 to 7 to force that mask, or QRCODE_MASK_AUTO to automatically choose an appropriate mask (which may be slow).</p><p>About the byte arrays, letting len = QRCODE_BUFFER_LEN_FOR_VERSION(QRCODE_VERSION_MAX): - Before calling the function: - The array ranges tempBuffer[0 : len] and qrcode[0 : len] must allow reading and writing; hence each array must have a length of at least len.&nbsp; - The two ranges must not overlap (aliasing).&nbsp; - The initial state of both ranges can be uninitialized because the function always writes before reading.&nbsp; - The input array segs can contain segments whose data buffers overlap with tempBuffer.&nbsp; - After the function returns: - Both ranges have no guarantee on which elements are initialized and what values are stored.&nbsp; - tempBuffer contains no useful data and should be treated as entirely uninitialized.&nbsp; - Any segment whose data buffer overlaps with tempBuffer[0 : len] must be treated as having invalid values in that array.&nbsp; - If successful, qrcode can be passed into QRCode_GetSize() and QRCode_GetModule().</p><p>Please consult the QR Code specification for information on data capacities per version, ECC level, and text encoding mode.</p><p>This function allows the user to create a custom sequence of segments that switches between modes (such as alphanumeric and byte) to encode text in less space.&nbsp; This is a low-level API; the high-level API is QRCode_EncodeText() and QRCode_EncodeBinary().</p></div>
</div>

<a name="QRCode_IsNumeric"></a><a name="Topic1117"></a><div class="CTopic TFunction LC">
 <div class="CTitle">QRCode_IsNumeric</div>
 <div id="NDPrototype1117" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">bool</span> QRCode_IsNumeric(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">const</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PSymbols">*</td><td class="PName last">text</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div></div>
 <div class="CBody"><p>Tests whether the given string can be encoded as a segment in numeric mode.&nbsp; A string is encodable iff each character is in the range 0 to 9.</p></div>
</div>

<a name="QRCode_IsAlphanumeric"></a><a name="Topic1118"></a><div class="CTopic TFunction LC">
 <div class="CTitle">QRCode_IsAlphanumeric</div>
 <div id="NDPrototype1118" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">bool</span> QRCode_IsAlphanumeric(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">const</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PSymbols">*</td><td class="PName last">text</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div></div>
 <div class="CBody"><p>Tests whether the given string can be encoded as a segment in alphanumeric mode.&nbsp; A string is encodable iff each character is in the following set: 0 to 9, A to Z (uppercase only), space, dollar, percent, asterisk, plus, hyphen, period, slash, colon.</p></div>
</div>

<a name="QRCode_CalcSegmentBufferSize"></a><a name="Topic1000"></a><div class="CTopic TFunction LC">
 <div class="CTitle">QRCode_CalcSegmentBufferSize</div>
 <div id="NDPrototype1000" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters">u16 QRCode_CalcSegmentBufferSize(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">enum</span>&nbsp;</td><td class="PType"><a href="../../index.html#File:tool/qrcode.h:QRCODE_MODE" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,834);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >QRCODE_MODE</a>&nbsp;</td><td class="PName last">mode,</td></tr><tr><td class="first"></td><td class="PType">u16&nbsp;</td><td class="PName last">numChars</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div></div>
 <div class="CBody"><p>Returns the number of bytes (u8) needed for the data buffer of a segment containing the given number of characters using the given mode. Notes: - Returns SIZE_MAX on failure, i.e. numChars &gt; INT16_MAX or the internal calculation of the number of needed bits exceeds INT16_MAX (i.e. 32767).&nbsp; - Otherwise, all valid results are in the range [0, ceil(INT16_MAX / 8)], i.e. at most 4096.&nbsp; - It is okay for the user to allocate more bytes for the buffer than needed.&nbsp; - For byte mode, numChars measures the number of bytes, not Unicode code points.&nbsp; - For ECI mode, numChars must be 0, and the worst-case number of bytes is returned.&nbsp; An actual ECI segment can have shorter data. For non-ECI modes, the result is exact.</p></div>
</div>

<a name="QRCode_MakeBytes"></a><a name="Topic590"></a><div class="CTopic TFunction LC">
 <div class="CTitle">QRCode_MakeBytes</div>
 <div id="NDPrototype590" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> QRCode_MakeBytes(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">const</span>&nbsp;</td><td class="PType">u8&nbsp;</td><td class="PName last">data[],</td></tr><tr><td class="first"></td><td class="PType">u16&nbsp;</td><td class="PName last">len,</td></tr><tr><td class="first"></td><td class="PType">u8&nbsp;</td><td class="PName last">buf[],</td></tr><tr><td class="first"></td><td class="PType">QRCode_Segment*&nbsp;</td><td class="PName last">seg</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div></div>
 <div class="CBody"><p>Returns a segment representing the given binary data encoded in byte mode. All input byte arrays are acceptable. Any text string can be converted to UTF-8 bytes and encoded as a byte mode segment.</p></div>
</div>

<a name="QRCode_MakeNumeric"></a><a name="Topic697"></a><div class="CTopic TFunction LC">
 <div class="CTitle">QRCode_MakeNumeric</div>
 <div id="NDPrototype697" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> QRCode_MakeNumeric(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">const</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PSymbols">*</td><td class="PName last">digits,</td></tr><tr><td class="first"></td><td class="PType">u8&nbsp;</td><td></td><td class="PName last">buf[],</td></tr><tr><td class="first"></td><td class="PType">QRCode_Segment*&nbsp;</td><td></td><td class="PName last">seg</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div></div>
 <div class="CBody"><p>Returns a segment representing the given string of decimal digits encoded in numeric mode.</p></div>
</div>

<a name="QRCode_MakeAlphanumeric"></a><a name="Topic698"></a><div class="CTopic TFunction LC">
 <div class="CTitle">QRCode_MakeAlphanumeric</div>
 <div id="NDPrototype698" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> QRCode_MakeAlphanumeric(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">const</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PSymbols">*</td><td class="PName last">text,</td></tr><tr><td class="first"></td><td class="PType">u8&nbsp;</td><td></td><td class="PName last">buf[],</td></tr><tr><td class="first"></td><td class="PType">QRCode_Segment*&nbsp;</td><td></td><td class="PName last">seg</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div></div>
 <div class="CBody"><p>Returns a segment representing the given text string encoded in alphanumeric mode.&nbsp; The characters allowed are: 0 to 9, A to Z (uppercase only), space, dollar, percent, asterisk, plus, hyphen, period, slash, colon.</p></div>
</div>

<a name="QRCode_MakeECI"></a><a name="Topic699"></a><div class="CTopic TFunction LC">
 <div class="CTitle">QRCode_MakeECI</div>
 <div id="NDPrototype699" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> QRCode_MakeECI(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PType first">i32&nbsp;</td><td class="PName last">assignVal,</td></tr><tr><td class="PType first">u8&nbsp;</td><td class="PName last">buf[],</td></tr><tr><td class="PType first">QRCode_Segment*&nbsp;</td><td class="PName last">seg</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div></div>
 <div class="CBody"><p>Returns a segment representing an Extended Channel Interpretation (ECI) designator with the given assignment value.</p></div>
</div>

<a name="QRCode_GetSize"></a><a name="Topic1124"></a><div class="CTopic TFunction LC">
 <div class="CTitle">QRCode_GetSize</div>
 <div id="NDPrototype1124" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters">u8 QRCode_GetSize(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">const</span>&nbsp;</td><td class="PType">u8&nbsp;</td><td class="PName last">qrcode[]</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div></div>
 <div class="CBody"><p>Returns the side length of the given QR Code, assuming that encoding succeeded.&nbsp; The result is in the range [21, 177]. Note that the length of the array buffer is related to the side length - every 'u8 qrcode[]' must have length at least QRCODE_BUFFER_LEN_FOR_VERSION(version), which equals ceil(size^2 / 8 + 1).</p></div>
</div>

<a name="QRCode_GetModule"></a><a name="Topic1125"></a><div class="CTopic TFunction LC">
 <div class="CTitle">QRCode_GetModule</div>
 <div id="NDPrototype1125" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">bool</span> QRCode_GetModule(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">const</span>&nbsp;</td><td class="PType">u8&nbsp;</td><td class="PName last">qrcode[],</td></tr><tr><td class="first"></td><td class="PType">u8&nbsp;</td><td class="PName last">x,</td></tr><tr><td class="first"></td><td class="PType">u8&nbsp;</td><td class="PName last">y</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div></div>
 <div class="CBody"><p>Returns the color of the module (pixel) at the given coordinates, which is FALSE for light or TRUE for dark.&nbsp; The top left corner has the coordinates (x=0, y=0).&nbsp; Coordinates must be in bounds.</p></div>
</div>

<a name="QRCode_GetByte"></a><a name="Topic1126"></a><div class="CTopic TFunction LC">
 <div class="CTitle">QRCode_GetByte</div>
 <div id="NDPrototype1126" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters">u8 QRCode_GetByte(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">const</span>&nbsp;</td><td class="PType">u8&nbsp;</td><td class="PName last">qrcode[],</td></tr><tr><td class="first"></td><td class="PType">u8&nbsp;</td><td class="PName last">x,</td></tr><tr><td class="first"></td><td class="PType">u8&nbsp;</td><td class="PName last">y</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div></div>
 <div class="CBody"><p>Returns colors of 8 module (byte) at the given coordinates, which is 0 for light or 1 for dark.&nbsp; The top left corner has the coordinates (x=0, y=0).</p></div>
</div>

<a name="QRCode_GetVersion"></a><a name="Topic1127"></a><div class="CTopic TFunction LC">
 <div class="CTitle">QRCode_GetVersion</div>
 <div id="NDPrototype1127" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">inline</span> u8 QRCode_GetVersion(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">const</span>&nbsp;</td><td class="PType">u8&nbsp;</td><td class="PName last">qrcode[]</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div></div>
</div>

<a name="QRCode_SetVersion"></a><a name="Topic1128"></a><div class="CTopic TFunction LC">
 <div class="CTitle">QRCode_SetVersion</div>
 <div id="NDPrototype1128" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">inline</span> <span class="SHKeyword">void</span> QRCode_SetVersion(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PType first">u8&nbsp;</td><td class="PName last">min,</td></tr><tr><td class="PType first">u8&nbsp;</td><td class="PName last">max</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div></div>
 <div class="CBody"><p>Set minimum and maximum version to use for the next encoding.&nbsp; Must be called before QRCode_Encode* functions.</p></div>
</div>

<a name="QRCode_SetBoostECL"></a><a name="Topic1129"></a><div class="CTopic TFunction LC last">
 <div class="CTitle">QRCode_SetBoostECL</div>
 <div id="NDPrototype1129" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">inline</span> <span class="SHKeyword">void</span> QRCode_SetBoostECL(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PType first"><span class="SHKeyword">bool</span>&nbsp;</td><td class="PName last">boost</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div></div>
 <div class="CBody"><p>Set ECC level boost option.</p></div>
</div>

</body></html>